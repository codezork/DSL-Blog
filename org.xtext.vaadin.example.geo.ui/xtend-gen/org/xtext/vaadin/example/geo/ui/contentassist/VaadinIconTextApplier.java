/**
 * generated by Xtext 2.19.0
 */
package org.xtext.vaadin.example.geo.ui.contentassist;

import com.vaadin.flow.component.icon.VaadinIcon;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.DirectColorModel;
import java.awt.image.IndexColorModel;
import java.awt.image.WritableRaster;
import java.net.URL;
import java.util.ArrayList;
import java.util.function.Consumer;
import org.eclipse.core.runtime.FileLocator;
import org.eclipse.core.runtime.Path;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.nebula.widgets.tablecombo.TableCombo;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.ImageData;
import org.eclipse.swt.graphics.PaletteData;
import org.eclipse.swt.graphics.RGB;
import org.eclipse.swt.layout.FillLayout;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.swt.widgets.Table;
import org.eclipse.swt.widgets.TableItem;
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ReplacementTextApplier;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.IntegerRange;
import org.osgi.framework.Bundle;
import org.osgi.framework.FrameworkUtil;

@SuppressWarnings("all")
public class VaadinIconTextApplier extends ReplacementTextApplier {
  private ContentAssistContext context;
  
  private ArrayList<Image> images = CollectionLiterals.<Image>newArrayList();
  
  public ContentAssistContext setContext(final ContentAssistContext context) {
    return this.context = context;
  }
  
  @Override
  public String getActualReplacementString(final ConfigurableCompletionProposal proposal) {
    Display display = this.context.getViewer().getTextWidget().getDisplay();
    Shell shell = new Shell(display);
    shell.setText("Vaadin Icons");
    shell.setSize(300, 100);
    FillLayout _fillLayout = new FillLayout();
    shell.setLayout(_fillLayout);
    TableCombo tc = new TableCombo(shell, (SWT.BORDER + SWT.READ_ONLY));
    Bundle bundle = FrameworkUtil.getBundle(this.getClass());
    String path = "/icons/vaadin_icons.png";
    Path _path = new Path(path);
    URL url = FileLocator.find(bundle, _path, null);
    ImageDescriptor imageDesc = ImageDescriptor.createFromURL(url);
    Image image = imageDesc.createImage();
    BufferedImage bufferedImage = this.convertToAWT(image.getImageData());
    final ArrayList<String> sel = CollectionLiterals.<String>newArrayList();
    tc.addSelectionListener(new SelectionAdapter() {
      @Override
      public void widgetSelected(final SelectionEvent e) {
        Object _source = e.getSource();
        sel.add(((TableCombo) _source).getText());
      }
    });
    tc.setClosePopupAfterSelection(true);
    int idx = 0;
    VaadinIcon[] _values = VaadinIcon.values();
    for (final VaadinIcon icon : _values) {
      {
        Table _table = tc.getTable();
        TableItem ti = new TableItem(_table, SWT.NONE);
        ti.setText(icon.name());
        ti.setImage(this.indexedImage(bufferedImage, idx, display));
        idx = (idx + 1);
      }
    }
    shell.pack();
    shell.open();
    shell.setCursor(display.getSystemCursor(SWT.CURSOR_IBEAM));
    while ((!shell.isDisposed())) {
      boolean _readAndDispatch = display.readAndDispatch();
      boolean _not = (!_readAndDispatch);
      if (_not) {
        display.sleep();
      }
    }
    final Consumer<Image> _function = (Image it) -> {
      it.dispose();
    };
    this.images.forEach(_function);
    this.images.clear();
    int _size = sel.size();
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      return "\"".concat(sel.get(0)).concat("\"");
    }
    return null;
  }
  
  public Image indexedImage(final BufferedImage bImage, final int idx, final Display display) {
    int w = 46;
    int h = 35;
    int offx = 18;
    int offy = 16;
    int col = (idx % 5);
    int row = ((idx - col) / 5);
    int y = (offy + (row * 57));
    int x = (offx + (col * 76));
    BufferedImage bIcon = null;
    bIcon = bImage.getSubimage(x, y, w, h);
    ImageData imageData = this.convertToSWT(bIcon);
    Image img = new Image(display, imageData);
    this.images.add(img);
    return img;
  }
  
  public BufferedImage convertToAWT(final ImageData data) {
    ColorModel colorModel = null;
    final PaletteData palette = data.palette;
    if (palette.isDirect) {
      DirectColorModel _directColorModel = new DirectColorModel(data.depth, palette.redMask, palette.greenMask, palette.blueMask);
      colorModel = _directColorModel;
      WritableRaster _createCompatibleWritableRaster = colorModel.createCompatibleWritableRaster(data.width, data.height);
      BufferedImage bufferedImage = new BufferedImage(colorModel, _createCompatibleWritableRaster, false, null);
      final WritableRaster raster = bufferedImage.getRaster();
      final int[] pixelArray = new int[3];
      final Consumer<Integer> _function = (Integer y) -> {
        final Consumer<Integer> _function_1 = (Integer x) -> {
          int pixel = data.getPixel((x).intValue(), (y).intValue());
          RGB rgb = palette.getRGB(pixel);
          pixelArray[0] = rgb.red;
          pixelArray[1] = rgb.green;
          pixelArray[2] = rgb.blue;
          raster.setPixels((x).intValue(), (y).intValue(), 1, 1, pixelArray);
        };
        new IntegerRange(0, (data.width - 1)).forEach(_function_1);
      };
      new IntegerRange(0, (data.height - 1)).forEach(_function);
      return bufferedImage;
    } else {
      final RGB[] rgbs = palette.getRGBs();
      final byte[] red = new byte[rgbs.length];
      final byte[] green = new byte[rgbs.length];
      final byte[] blue = new byte[rgbs.length];
      int _length = rgbs.length;
      int _minus = (_length - 1);
      final Consumer<Integer> _function_1 = (Integer i) -> {
        RGB rgb = rgbs[(i).intValue()];
        red[(i).intValue()] = ((byte) rgb.red);
        green[(i).intValue()] = ((byte) rgb.green);
        blue[(i).intValue()] = ((byte) rgb.blue);
      };
      new IntegerRange(0, _minus).forEach(_function_1);
      if ((data.transparentPixel != (-1))) {
        int _length_1 = rgbs.length;
        IndexColorModel _indexColorModel = new IndexColorModel(data.depth, _length_1, red, green, blue, data.transparentPixel);
        colorModel = _indexColorModel;
      } else {
        int _length_2 = rgbs.length;
        IndexColorModel _indexColorModel_1 = new IndexColorModel(data.depth, _length_2, red, green, blue);
        colorModel = _indexColorModel_1;
      }
      WritableRaster _createCompatibleWritableRaster_1 = colorModel.createCompatibleWritableRaster(data.width, data.height);
      BufferedImage bufferedImage_1 = new BufferedImage(colorModel, _createCompatibleWritableRaster_1, false, null);
      final WritableRaster raster_1 = bufferedImage_1.getRaster();
      final int[] pixelArray_1 = new int[1];
      final Consumer<Integer> _function_2 = (Integer y) -> {
        final Consumer<Integer> _function_3 = (Integer x) -> {
          int pixel = data.getPixel((x).intValue(), (y).intValue());
          pixelArray_1[0] = pixel;
          raster_1.setPixel((x).intValue(), (y).intValue(), pixelArray_1);
        };
        new IntegerRange(0, (data.width - 1)).forEach(_function_3);
      };
      new IntegerRange(0, (data.height - 1)).forEach(_function_2);
      return bufferedImage_1;
    }
  }
  
  public ImageData convertToSWT(final BufferedImage bufferedImage) {
    ColorModel _colorModel = bufferedImage.getColorModel();
    if ((_colorModel instanceof DirectColorModel)) {
      ColorModel _colorModel_1 = bufferedImage.getColorModel();
      DirectColorModel colorModel = ((DirectColorModel) _colorModel_1);
      int _redMask = colorModel.getRedMask();
      int _greenMask = colorModel.getGreenMask();
      int _blueMask = colorModel.getBlueMask();
      final PaletteData palette = new PaletteData(_redMask, _greenMask, _blueMask);
      int _width = bufferedImage.getWidth();
      int _height = bufferedImage.getHeight();
      int _pixelSize = colorModel.getPixelSize();
      final ImageData data = new ImageData(_width, _height, _pixelSize, palette);
      final WritableRaster raster = bufferedImage.getRaster();
      final int[] pixelArray = new int[3];
      final Consumer<Integer> _function = (Integer y) -> {
        final Consumer<Integer> _function_1 = (Integer x) -> {
          raster.getPixel((x).intValue(), (y).intValue(), pixelArray);
          int _get = pixelArray[0];
          int _get_1 = pixelArray[1];
          int _get_2 = pixelArray[2];
          RGB _rGB = new RGB(_get, _get_1, _get_2);
          int pixel = palette.getPixel(_rGB);
          data.setPixel((x).intValue(), (y).intValue(), pixel);
        };
        new IntegerRange(0, (data.width - 1)).forEach(_function_1);
      };
      new IntegerRange(0, (data.height - 1)).forEach(_function);
      return data;
    } else {
      ColorModel _colorModel_2 = bufferedImage.getColorModel();
      if ((_colorModel_2 instanceof IndexColorModel)) {
        ColorModel _colorModel_3 = bufferedImage.getColorModel();
        IndexColorModel colorModel_1 = ((IndexColorModel) _colorModel_3);
        int size = colorModel_1.getMapSize();
        final byte[] reds = new byte[size];
        final byte[] greens = new byte[size];
        final byte[] blues = new byte[size];
        colorModel_1.getReds(reds);
        colorModel_1.getGreens(greens);
        colorModel_1.getBlues(blues);
        final ArrayList<RGB> rgbs = CollectionLiterals.<RGB>newArrayList();
        final Consumer<Integer> _function_1 = (Integer i) -> {
          RGB _rGB = new RGB(((int) ((reds[(i).intValue()]) & 0xFF)), ((int) ((greens[(i).intValue()]) & 0xFF)), 
            ((int) ((blues[(i).intValue()]) & 0xFF)));
          rgbs.add(_rGB);
        };
        new IntegerRange(0, (size - 1)).forEach(_function_1);
        PaletteData palette_1 = new PaletteData(((RGB[])Conversions.unwrapArray(rgbs, RGB.class)));
        int _width_1 = bufferedImage.getWidth();
        int _height_1 = bufferedImage.getHeight();
        int _pixelSize_1 = colorModel_1.getPixelSize();
        final ImageData data_1 = new ImageData(_width_1, _height_1, _pixelSize_1, palette_1);
        data_1.transparentPixel = colorModel_1.getTransparentPixel();
        final WritableRaster raster_1 = bufferedImage.getRaster();
        final int[] pixelArray_1 = new int[1];
        final Consumer<Integer> _function_2 = (Integer y) -> {
          final Consumer<Integer> _function_3 = (Integer x) -> {
            raster_1.getPixel((x).intValue(), (y).intValue(), pixelArray_1);
            data_1.setPixel((x).intValue(), (y).intValue(), pixelArray_1[0]);
          };
          new IntegerRange(0, (data_1.width - 1)).forEach(_function_3);
        };
        new IntegerRange(0, (data_1.height - 1)).forEach(_function_2);
        return data_1;
      }
    }
    return null;
  }
}
