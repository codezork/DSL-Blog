/*
 * generated by Xtext 2.19.0
 */
package org.xtext.vaadin.example.geo.ui.contentassist

import com.google.inject.Inject
import com.vaadin.flow.component.icon.VaadinIcon
import java.awt.image.BufferedImage
import java.awt.image.ColorModel
import java.awt.image.DirectColorModel
import java.awt.image.IndexColorModel
import org.eclipse.core.runtime.FileLocator
import org.eclipse.core.runtime.Path
import org.eclipse.emf.ecore.EObject
import org.eclipse.jface.resource.ImageDescriptor
import org.eclipse.nebula.widgets.tablecombo.TableCombo
import org.eclipse.swt.SWT
import org.eclipse.swt.events.SelectionAdapter
import org.eclipse.swt.events.SelectionEvent
import org.eclipse.swt.graphics.Image
import org.eclipse.swt.graphics.ImageData
import org.eclipse.swt.graphics.PaletteData
import org.eclipse.swt.graphics.RGB
import org.eclipse.swt.layout.FillLayout
import org.eclipse.swt.widgets.Display
import org.eclipse.swt.widgets.FileDialog
import org.eclipse.swt.widgets.Shell
import org.eclipse.swt.widgets.TableItem
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.common.ui.contentassist.TerminalsProposalProvider
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.eclipse.xtext.ui.editor.contentassist.ReplacementTextApplier
import org.osgi.framework.FrameworkUtil

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
class GeoDslProposalProvider extends AbstractGeoDslProposalProvider {
	@Inject TerminalsProposalProvider provider

	override protected isKeywordWorthyToPropose(Keyword keyword) {
		return true
	}

	override complete_ID(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		provider.complete_ID(model, ruleCall, context, acceptor)
	}

	override complete_STRING(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		provider.complete_STRING(model, ruleCall, context, acceptor)
	}

	override complete_INT(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		provider.complete_INT(model, ruleCall, context, acceptor)
	}

	override completeGeoLayout_LogoPath(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		filePickerProposal(model, assignment, context, acceptor, "*.png")
	}

	override completeGeoTab_Topology(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		filePickerProposal(model, assignment, context, acceptor, "*.json")
	}

	override completeGeoModel_Style(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		filePickerProposal(model, assignment, context, acceptor, "*.html")
	}

	override completeGeoTab_IconName(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		iconPickerProposal(model, assignment, context, acceptor)
	}

	def filePickerProposal(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor, String fileExtensions) {
		var fileName = createCompletionProposal("Select input file...", context) as ConfigurableCompletionProposal
		if (fileName !== null) {
			var applier = new FileNameTextApplier()
			applier.setExtensions(fileExtensions.split(","))
			applier.setContext(context)
			fileName.setTextApplier = applier
		}
		acceptor.accept(fileName)
	}

	def iconPickerProposal(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		var fileName = createCompletionProposal("Select input file...", context) as ConfigurableCompletionProposal
		if (fileName !== null) {
			var applier = new VaadinIconTextApplier()
			applier.setContext(context)
			fileName.setTextApplier = applier
		}
		acceptor.accept(fileName)
	}
}

class FileNameTextApplier extends ReplacementTextApplier {
	var ContentAssistContext context
	var String[] extensions

	def setContext(ContentAssistContext context) {
		this.context = context
	}

	def setExtensions(String[] fileExtensions) {
		extensions = fileExtensions
	}

	// this will inject a file dialog when selecting the file picker proposal 
	override getActualReplacementString(ConfigurableCompletionProposal proposal) {
		var display = context.getViewer().getTextWidget().getDisplay()
		var fileDialog = new FileDialog(display.getActiveShell())
		fileDialog.setFilterExtensions(extensions)
		var fileName = fileDialog.open()
		fileName = fileName.replace("\\", "/")
		return "\"".concat(fileName).concat("\"")
	}
}

class VaadinIconTextApplier extends ReplacementTextApplier {
	var ContentAssistContext context
	var images = <Image>newArrayList

	def setContext(ContentAssistContext context) {
		this.context = context
	}

	// this will inject a file dialog when selecting the file picker proposal 
	override getActualReplacementString(ConfigurableCompletionProposal proposal) {
		var display = context.getViewer().getTextWidget().getDisplay()
		var shell = new Shell(display)
		shell.setText("Vaadin Icons")
		shell.setSize(300, 100)
		shell.setLayout(new FillLayout())
		var tc = new TableCombo(shell, (SWT.BORDER + SWT.READ_ONLY))

		var bundle = FrameworkUtil.getBundle(getClass())
		// Relative path in the plugin
		var path = "/icons/vaadin_icons.png"
		var url = FileLocator.find(bundle, new Path(path), null)
		var imageDesc = ImageDescriptor.createFromURL(url)
		var image = imageDesc.createImage()
		var bufferedImage = image.imageData.convertToAWT

		val sel = <String>newArrayList
		tc.addSelectionListener(new SelectionAdapter() {
			override widgetSelected(SelectionEvent e) {
				sel.add((e.source as TableCombo).text)
			}
		})
		tc.setClosePopupAfterSelection(true)

		var idx = 0
		for (icon : VaadinIcon.values()) {
			var ti = new TableItem(tc.getTable(), SWT.NONE)
			ti.text = icon.name
			ti.image = indexedImage(bufferedImage, idx, display)
			idx = idx + 1
		}

		shell.pack()
		shell.open()
		shell.setCursor(display.getSystemCursor(SWT.CURSOR_IBEAM))

		while (!shell.isDisposed()) {
			if (!display.readAndDispatch())
				display.sleep()
		}
		images.forEach[it.dispose]
		images.clear
		if(sel.size > 0) {
			return "\"".concat(sel.get(0)).concat("\"")
		}
		return null
	}

	def Image indexedImage(BufferedImage bImage, int idx, Display display) {
		var w = 46
		var h = 35
		var offx = 18
		var offy = 16
		var col = idx%5
		var row = (idx - col)/5
		var y = offy+row*57
		var x = offx+col*76
		var BufferedImage bIcon
		bIcon = bImage.getSubimage(x,y,w,h)
		var imageData = bIcon.convertToSWT
		var img = new Image(display, imageData)
		images.add(img)
		return img		
	}

	def BufferedImage convertToAWT(ImageData data) {
		var ColorModel colorModel = null
		val palette = data.palette
		if (palette.isDirect) {
			colorModel = new DirectColorModel(data.depth, palette.redMask, palette.greenMask, palette.blueMask)
			var bufferedImage = new BufferedImage(colorModel,
				colorModel.createCompatibleWritableRaster(data.width, data.height), false, null)
			val raster = bufferedImage.getRaster()
			val pixelArray = newIntArrayOfSize(3)
			(0 .. data.height - 1).forEach [ y |
				(0 .. data.width - 1).forEach [ x |
					var pixel = data.getPixel(x, y)
					var rgb = palette.getRGB(pixel)
					pixelArray.set(0, rgb.red)
					pixelArray.set(1, rgb.green)
					pixelArray.set(2, rgb.blue)
					raster.setPixels(x, y, 1, 1, pixelArray)
				]
			]
			return bufferedImage
		} else {
			val rgbs = palette.getRGBs()
			val red = newByteArrayOfSize(rgbs.length)
			val green = newByteArrayOfSize(rgbs.length)
			val blue = newByteArrayOfSize(rgbs.length)
			(0 .. rgbs.length - 1).forEach [ i |
				var rgb = rgbs.get(i)
				red.set(i, rgb.red as byte)
				green.set(i, rgb.green as byte)
				blue.set(i, rgb.blue as byte)
			]
			if (data.transparentPixel != -1) {
				colorModel = new IndexColorModel(data.depth, rgbs.length, red, green, blue, data.transparentPixel)
			} else {
				colorModel = new IndexColorModel(data.depth, rgbs.length, red, green, blue)
			}
			var bufferedImage = new BufferedImage(colorModel,
				colorModel.createCompatibleWritableRaster(data.width, data.height), false, null)
			val raster = bufferedImage.getRaster()
			val pixelArray = newIntArrayOfSize(1)
			(0 .. data.height - 1).forEach [ y |
				(0 .. data.width - 1).forEach [ x |
					var pixel = data.getPixel(x, y)
					pixelArray.set(0, pixel)
					raster.setPixel(x, y, pixelArray)
				]
			]
			return bufferedImage
		}
	}

	def ImageData convertToSWT(BufferedImage bufferedImage) {
		if (bufferedImage.getColorModel() instanceof DirectColorModel) {
			var colorModel = bufferedImage.getColorModel() as DirectColorModel
			val palette = new PaletteData(colorModel.getRedMask(), colorModel.getGreenMask(), colorModel.getBlueMask())
			val data = new ImageData(bufferedImage.getWidth(), bufferedImage.getHeight(), colorModel.getPixelSize(),
				palette)
			val raster = bufferedImage.getRaster()
			val pixelArray = newIntArrayOfSize(3)
			(0 .. data.height - 1).forEach [ y |
				(0 .. data.width - 1).forEach [ x |
					raster.getPixel(x, y, pixelArray)
					var pixel = palette.getPixel(new RGB(pixelArray.get(0), pixelArray.get(1), pixelArray.get(2)))
					data.setPixel(x, y, pixel)
				]
			]
			return data
		} else if (bufferedImage.getColorModel() instanceof IndexColorModel) {
			var colorModel = bufferedImage.getColorModel() as IndexColorModel
			var size = colorModel.getMapSize()
			val reds = newByteArrayOfSize(size)
			val greens = newByteArrayOfSize(size)
			val blues = newByteArrayOfSize(size)
			colorModel.getReds(reds)
			colorModel.getGreens(greens)
			colorModel.getBlues(blues)
			val rgbs = <RGB>newArrayList()
			(0 .. size - 1).forEach [ i |
				rgbs.add(
					new RGB(reds.get(i).bitwiseAnd(0xFF) as int, greens.get(i).bitwiseAnd(0xFF) as int,
						blues.get(i).bitwiseAnd(0xFF) as int))
			]
			var palette = new PaletteData(rgbs)
			val data = new ImageData(bufferedImage.getWidth(), bufferedImage.getHeight(), colorModel.getPixelSize(),
				palette)
			data.transparentPixel = colorModel.getTransparentPixel()
			val raster = bufferedImage.getRaster()
			val pixelArray = newIntArrayOfSize(1)
			(0 .. data.height - 1).forEach [ y |
				(0 .. data.width - 1).forEach [ x |
					raster.getPixel(x, y, pixelArray)
					data.setPixel(x, y, pixelArray.get(0))
				]
			]
			return data
		}
		return null
	}
}
